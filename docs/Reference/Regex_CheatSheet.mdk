Title : 正则表达式

Bib style : plainnat
Bibliography : example

equation {
  toc: equations;
  toc-line: "&label;&ensp;&caption;";
}

Doc class : [onecolumn, a4paper, 12pt]article

pre,code {
  color: red;
}

Package: [curve]xypic
Package: amscd
Package: amsfonts
Package: amsmath
Package: fontspec
Package: xeCJK
Package: geometry
Package: pgfplots
Package: pgfplotstable
Package: pst-plot
Package: pstricks
Package: tikz

Tex Header:
  \setmainfont{Times New Roman}
  \setsansfont{Arial}
  \setmonofont{Courier New}
  \setCJKmainfont[BoldFont={SimHei},ItalicFont={SimHei}]{SimSun}
  \setCJKsansfont[BoldFont={SimHei},ItalicFont={SimHei}]{SimSun}
  \setCJKmonofont[BoldFont={SimHei},ItalicFont={SimHei}]{SimSun}
  \XeTeXlinebreaklocale "zh"
  \XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
  \geometry{top=1.2in,bottom=1.2in,left=1.2in,right=1.2in}
  \usetikzlibrary{decorations.pathreplacing%
  ,decorations.pathmorphing}

[INCLUDE=book]
[INCLUDE=webtoc]
[INCLUDE=webanchors]

[TITLE]

~ Begin SidePanel

[TOC]

~ End SidePanel


~ Begin MainPanel



# 1. 正则表达式简介 {-}

正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。

许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen。

正则表达式引擎是一种可以处理正则表达式的软件。通常，引擎是更大的应用程序的一部分。在软件世界，不同的正则表达式并不互相兼容。知道正则表达式引擎是如何工作的有助于你很快理解为何某个正则表达式不像你期望的那样工作。

正则表达式引擎有两种类型的引擎：文本导向(text-directed)的引擎和正则导向(regex-directed)的引擎，分别被称作DFA(确定性有限状态自动机) 引擎和NFA(非确定有限状态自动机)引擎。这两种引擎都有了很久的历史(至今二十多年)，当中也由这两种引擎产生了很多变体。POSIX的出台规避了不必要变体的继续产生。这样一来，主流的正则引擎又分为3类： DFA、传统型NFA、POSIX NFA。

- DFA引擎在线性时状态下执行，因为它们不要求回溯（并因此它们永远不测试相同的字符两次）。DFA引擎还可以确保匹配最长的可能的字符串。但是，因为 DFA 引擎只包含有限的状态，所以它不能匹配具有反向引用的模式；并且因为它不构造显示扩展，所以它不可以捕获子表达式。
- 传统的NFA引擎运行所谓的“贪婪的”匹配回溯算法，以指定顺序测试正则表达式的所有可能的扩展并接受第一个匹配项。因为传统的NFA构造正则表达式的特定扩展以获得成功的匹配，所以它可以捕获子表达式匹配和匹配的反向引用。但是，因为传统的 NFA 回溯，所以它可以访问完全相同的状态多次（如果通过不同的路径到达该状态）。因此，在最坏情况下，它的执行速度可能非常慢。因为传统的 NFA接受它找到的第一个匹配，所以它还可能会导致其他（可能更长）匹配未被发现。一些非常有用的特性，如“惰性”量词(lazy quantifiers)和反向引用(back references)，只能在NFA引擎中实现。
- POSIX NFA 引擎与传统的NFA引擎类似，不同的一点在于：在它们可以确保已找到了可能的最长的匹配之前，它们将继续回溯。因此，POSIX NFA引擎的速度慢于传统的NFA引擎；并且在使用POSIX NFA时，您恐怕不会愿意在更改回溯搜索的顺序的情况下来支持较短的匹配搜索，而非较长的匹配搜索。

使用DFA引擎的程序主要有：awk，egrep，flex，lex，MySQL，Procmail等；
使用传统型NFA引擎的程序主要有：GNU Emacs，Java，ergp，less，more，.NET，PCRE library，Perl，PHP，Python，Ruby，sed，vi；
使用POSIX NFA引擎的程序主要有：mawk，Mortice Kern Systems’ utilities，GNU Emacs(使用时可以明确指定)；
使用DFA/NFA混合的引擎：GNU awk，GNU grep/egrep，Tcl。

举例简单说明NFA与DFA工作的区别。比如有字符串 `this is yaabc’s blog`，正则表达式为 `ya(msen|nsen|nsem)`。 

NFA工作方式如下，先在字符串中查找 `y` 然后匹配其后是否为 `a`，如果是 `a` 则继续，查找其后是否为 `m` 如果不是则匹配其后是否为 `n` (此时淘汰 `msen` 选择支)。然后继续看其后是否依次为 `s`， `e`，接着测试是否为 `n`，是 `n`则匹配成功，不是则测试是否为 `m`。因为NFA工作方式是以正则表达式为标准，反复测试字符串，这样同样一个字符串有可能被反复测试了很多次。而DFA则不是如此，DFA会从 `this` 中 `t` 开始依次查找 `y`，定位到 `y`，已知其后为 `a`，则查看表达式是否有 `a`，此处正好有 `a`。然后字符串 `a` 后为 `n`，DFA依次测试表达式，此时 `msen` 不符合要求淘汰。`nsen` 和 `nsem` 符合要求，然后DFA依次检查字符串，检测到 `sen` 中的 `n` 时只有 `nsen` 分支符合，则匹配成功。

你可以轻易分辨出所使用的引擎是文本导向还是正则导向。如果反向引用或“惰性”量词被实现，则可以肯定你使用的引擎是正则导向的。你可以作如下测试：将正则表达式 `<<regex|regex not>>` 应用到字符串 `regex not`。如果匹配的结果是 `regex`，则引擎是正则导向的。如果结果是 `regex not`，则是文本导向的。这是因为正则导向的引擎总是返回最左边的匹配。这是需要理解的很重要的一点：即使以后有可能发现一个“更好”的匹配，正则导向的引擎也总是返回最左边的匹配。

NFA以表达式为主导，DFA以文本为主导。一般而论，DFA引擎则搜索更快一些；但是NFA以表达式为主导，反而更容易操纵，因此一般程序员更偏爱NFA引擎。两种引擎各有所长，而真正的引用则取决与你的需要以及所使用的语言。

# 2. 正则表达式语法 {-}

## 2.1. 转义字符 {-}

一些不便书写的字符，比如换行符，制表符等，使用 `\n`，`\t` 来表示。另外有一些标点符号在正则表达式中，被定义了特殊的意义，因此需要在前面加 `\` 进行转义后，匹配该字符本身。

|-----------------|-------------------------------------------------------------------------|
|转义符           |说明                                                                     |
|---{width:20%}---|---{width:20cm}----------------------------------------------------------|
|`\a`             |响铃符 = `\x07`                                                          |
|`\f`             |换页符 = `\x0C`                                                          |
|`\n`             |换行符 = `\x0A`                                                          |
|`\r`             |回车符 = `\x0D`                                                          |
|`\t`             |制表符 = `\x09`                                                          |
|`\v`             |垂直制表符 = `\x0B`                                                      |
|`\e`             |ESC符 = `\x1B`                                                           |
|`\x20`           |使用两位十六进制表示形式，可与该编号的字符匹配                           |
|`\u002B`         |使用四位十六进制表示形式，可与该编号的字符匹配                           |
|`\x{20A060}`     |使用任意位十六进制表示形式，可与该编号的字符匹配                         |
|`^`              |匹配输入字符串的开始位置。要匹配 `^` 字符本身，请使用 `\^`               |
|`$`             |匹配输入字符串的结尾位置。要匹配 `$` 字符本身，请使用 `\$`               |
|`( )`            |标记一个子表达式的开始和结束位置。要匹配小括号，请使用 `\(` 和 `\)`      |
|`[ ]`            |用来自定义能够匹配 '多种字符' 的表达式。要匹配中括号，请使用 `\[` 和 `\]`|
|`{ }`            |修饰匹配次数的符号。要匹配大括号，请使用 `\{` 和 `\}`                    |
|`.`              |匹配除了换行符（`\n`）以外的任意一个字符。要匹配小数点本身，请使用 `\.`  |
|`?`              |修饰匹配次数为 0 次或 1 次。要匹配 `?` 字符本身，请使用 `\?`             |
|`+`              |修饰匹配次数为至少 1 次。要匹配 `+` 字符本身，请使用 `\+`                |
|`*`              |修饰匹配次数为 0 次或任意次。要匹配 `*` 字符本身，请使用 `\*`            |
|[\|]{color:red}  |左右两边表达式之间 "或" 关系。匹配 [\|]{color:red} 本身，请使用 `\|`     |
|`\`              |用来进行转义的转义字符。匹配 `\` 本身，请使用 `\\`                      |
|-----------------|-------------------------------------------------------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

## 2.2. 控制转义字符 {-}

使用 `\Q` 开始，`\E` 结束，可使中间的标点符号失去特殊意义，将中间的字符作为普通字符。

使用 `\U` 开始，`\E` 结束，除了具有 `\Q...\E` 相同的功能外，还将中间的小写字母转换成大写。在大小写敏感模式下，只能与大写文本匹配。

使用 `\L` 开始，`\E` 结束，除了具有 `\Q...\E` 相同的功能外，还将中间的大写字母转换成小写。在大小写敏感模式下，只能与小写文本匹配。

## 2.3. 字符集合 {-}

可以匹配 "多个字符" 其中任意一个字符的正则表达式。虽然是 "多个字符"，但每次只能匹配其中一个。

正则表达式中标准的字符集合有：

|-----------------|-------------------------------------------------------|
|字符             |集合说明                                               |
|---{width:20%}---|---{width:20cm}----------------------------------------|
|`.`              |小数点可以匹配除了换行符（`\n`）以外的任意一个字符     |
|`\w`             |可以匹配任何一个字母或者数字或者下划线                 |
|`\W`             |W大写，可以匹配任何一个字母或者数字或者下划线以外的字符|
|`\s`             |可以匹配空格、制表符、换页符等空白字符的其中任意一个   |
|`\S`             |S大写，可以匹配任何一个空白字符以外的字符              |
|`\d`             |可以匹配任何一个 `0~9` 数字字符                        |
|`\D`             |D大写，可以匹配任何一个非数字字符                      |
|`[:alpha:]`      |POSIX 格式，可以匹配任何一个字母                       |
|`[:^alpha:]`     |POSIX 否定格式，可以匹配任何一个字母以外的字符         |
|-----------------|-------------------------------------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

POSIX 字符集合定义有：

|-----------------|------------------------------------------------------|
|POSIX 字符集合   |说明                                                  |
|---{width:20%}---|---{width:20cm}---------------------------------------|
|`[:alnum:]`      |任何一个字母或数字（`A-Z`, `a-z`, `0-9`）             |
|`[:alpha:]`      |任何一个字母（`A-Z`, `a-z`）                          |
|`[:ascii:]`      |任何一个 ASCII 范围内字符（`\x00–\x7F`）              |
|`[:cntrl:]`      |任何一个控制字符（`\x00–\x1F`, `\x7F`）               |
|`[:digit:]`      |任何一个数字（`0–9`）                                 |
|`[:print:]`      |任何一个可显示的 ASCII 字符（`\x20–\x7E`）            |
|`[:space:]`      |任何一个空白字符（`\x09–\x0D`, `\x20`）               |
|`[:graph:]`      |任何一个可显示的 ASCII 字符，不包含空格（`\x21–\x7E`）|
|`[:lower:]`      |任何一个小写字母（`a–z`）                             |
|`[:punct:]`      |可显示字符 `[:print:]` 中除去字母数字 `[:alnum:]`     |
|`[:upper:]`      |任何一个大写字母（`A–Z`）                             |
|`[:xdigit:]`     |任何一个十六进制数字（`0-9`, `A-F`, `a-f`）           |
|`[:blank:]`      |空格或者制表符（`\x20`, `\x09`）                      |
|-----------------|------------------------------------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

## 2.4. 自定义字符集合 {-}

用中括号 `[ ]` 包含多个字符，可以匹配所包含的字符中的任意一个。同样，每次只能匹配其中一个。比如 `[abc]` 会匹配 `a`， `b`， `c` 中的任意一个字符。

用中括号 `[^ ]` 包含多个字符，构成否定格式，可以匹配所包含的字符之外的任意一个字符。比如 `[^abc]` 会匹配除 `a`， `b`， `c` 外的任意一个字符。

- 正则表达式中的特殊符号，如果被包含于中括号中，则失去特殊意义，但 `\ [ ] : ^ -` 除外。
- 标准字符集合，除小数点(`.`)外，如果被包含于中括号中，自定义字符集合将包含该集合。比如：`[\d.-+]`，将可以匹配数字，小数点和 `+ -` 符号。（小数点和 `+` 号失去特殊意义）
- 用减号相连的 2 个普通字符，自定义字符集合将包含该范围。比如：`[\dA-Fa-f]`，将可以匹配 `0 - 9`，`A - F`，`a - f`。
- 自定义字符集合可以包含 POSIX 字符集合。

## 2.5. 匹配次数限定符 {-}

使被修饰的表达式可多次重复匹配的修饰符。可使被修饰的表达式重复固定次数，也可以限定一定的重复匹配的次数范围。

在限定符之后的表达式能够匹配成功的情况下，不定次数的限定符总是尽可能的多匹配。如果之后的表达式匹配失败，限定符可适当“让出”能够匹配的字符，以使整个表达式匹配成功。这种模式就叫“贪婪模式”。

|-----------------|---------------------------------------------------------------------------|
|限定符           |说明                                                                       |
|---{width:20%}---|---{width:20cm}------------------------------------------------------------|
|`{n}`            |表达式固定重复n次，比如：`\w{2}` 相当于 `\w\w`                             |
|`{m, n}`         |表达式尽可能重复n次，至少重复m次：`ba{1,3}`可以匹配 `ba` 或 `baa` 或 `baaa`|
|`{m, }`          |表达式尽可能的多匹配，至少重复m次：`\w\d{2,}`可以匹配 `a12`, `x456`...     |
|`?`              |表达式尽可能匹配1次，也可以不匹配，相当于 `{0, 1}`                         |
|`+`              |表达式尽可能的多匹配，至少匹配1次，相当于 `{1, }`                          |
|`*`              |表达式尽可能的多匹配，最少可以不匹配，相当于 `{0, }`                       |
|-----------------|---------------------------------------------------------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

### 2.5.1. “勉强模式”限定符 {-}

在限定符之后添加问号(`?`)，则使限定符成为“勉强模式”。勉强模式的限定符，总是尽可能少的匹配。如果之后的表达式匹配失败，勉强模式也可以尽可能少的再匹配一些，以使整个表达式匹配成功。

|-----------------|------------------------------------------------------|
|限定符           |说明                                                  |
|---{width:20%}---|---{width:20cm}---------------------------------------|
|`{m, n}?`        |表达式尽量只匹配m次，最多重复n次。                    |
|`{m, }?`         |表达式尽量只匹配m次，最多可以匹配任意次。             |
|`??`             |表达式尽量不匹配，最多匹配1次，相当于 `{0, 1}?`       |
|`+?`             |表达式尽量只匹配1次，最多可匹配任意次，相当于 `{1, }?`|
|`*?`             |表达式尽量不匹配，最多可匹配任意次，相当于 `{0, }?`   |
|-----------------|------------------------------------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

### 2.5.2. “占有模式”限定符 {-}

在限定符之后添加加号(`+`)，则使限定符成为“占有模式”。占有模式的限定符，总是尽可能多的匹配。与“贪婪模式”不同的是，即使之后的表达式匹配失败，“占有模式”也不会“让出”自己能够匹配的字符。

|-----------------|-----------------------------------------------------|
|限定符           |说明                                                 |
|---{width:20%}---|---{width:20cm}--------------------------------------|
|`{m, n}+`        |表达式尽可能重复n次，至少重复m次。                   |
|`{m, }+`         |表达式尽可能的多匹配，至少重复m次。                  |
|`?+`             |表达式尽可能匹配1次，也可以不匹配，相当于 `{0, 1}+`  |
|`++`             |表达式尽可能的多匹配，至少匹配1次，相当于 `{1, }+`   |
|`*+`             |表达式尽可能的多匹配，最少可以不匹配，相当于 `{0, }+`|
|-----------------|-----------------------------------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

## 2.6. 字符边界 {-}

本身不匹配任何字符，只对字符边界和字符间缝隙附加条件的表达式。

|-----------------|--------------------------------------------------|
|边界条件         |说明                                              |
|---{width:20%}---|---{width:20cm}-----------------------------------|
|`^`              |当前位置必须是文本开始位置。                      |
|`$`              |当前位置必须是文本结束位置。                      |
|`\b`             |当前位置的左右两侧，只能有一侧是字母数字或下划线。|
|-----------------|--------------------------------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

- 当 `\b` 被包含于字符集合中时，`\b` 代表退格符（ASCII码 = 8）。这个边界符常常用来匹配单词边界，比如，`\bend\b` 匹配单词 `end`，但不会匹配到 `weekend`。

## 2.7. 选择表达式 {-}

使用竖线 `|` 分隔多段表达式，整个表达式可匹配其中任意一段。

## 2.8. 捕获组 {-}

捕获组，就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。
捕获组有两种形式，一种是普通捕获组 `( )`，另一种是命名捕获组 `(?<name>xxx)`。

举例来说，使用普通捕获组匹配一个时间数字串，这种方式只能通过编号来访问捕获组。捕获组的编号是按照 `(` 出现的顺序，从左到右，从1开始进行编号的，注意，编号0代表整个匹配的字符串 。

|-----------------|------------------------|------------------|
|编号             |捕获组                  |匹配内容          |
|---{width:20%}---|---{width:40%}----------|---{width:10cm}---|
|0                |`(\d{4})-(\d{2}-(\d\d))`|2008-12-31        |
|1                |`(\d{4})`               |2008              |
|2                |`(\d{2}-(\d\d))`        |12-31             |
|3                |`(\d\d)`                |31                |
|-----------------|------------------------|------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

接着，使用命名捕获组匹配一个时间数字串，这种方式既可通过编号来访问各组，也可以直接通过命名来访问各组。

|-----------------|----------------|--------------------------------------------|------------------|
|编号             |命名            |捕获组                                      |匹配内容          |
|---{width:10%}---|---{width:10%}--|-{width:50%}--------------------------------|---{width:10cm}---|
|0                |-               |`(?<year>\d{4})-(?<date>\d{2}-(?<day>\d\d))`|2008-12-31        |
|1                |year            |`(?<year>\d{4})`                            |2008              |
|2                |date            |`(?<date>\d{2}-(?<day>\d\d))`               |12-31             |
|3                |day             |`(?<day>\d\d)`                              |31                |
|-----------------|----------------|--------------------------------------------|------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

## 2.9. 非捕获组 {-}

使用 `(?: )` 包含其他表达式，可使被包含的表达式组成一个整体，在被修饰匹配次数时，可作为整体被修饰。与普通分组不同的是，非捕获组不记录所匹配的内容，比普通分组更节约内存资源。

## 2.10. 反向引用 {-}

捕获组捕获到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。反向引用的作用通常是用来查找或限定重复，限定指定标识配对出现等等。反向引用提供了标识字符串中的重复字符或子字符串的方便途径。 例如，如果输入字符串包含某任意子字符串的多个匹配项，则可以使用捕获组匹配第一个出现的子字符串，然后使用反向引用匹配后面出现的子字符串。

普通捕获组反向引用： `\number`。其中编号 number 是正则表达式中捕获组的序号位置。 
命名捕获组反向引用： `\k<name>` 或者 `\k'name'`。其中 name 是正则表达式模式中定义的捕获组的名字的地方。

举例来说，表达式`(?:([0-9])(?!\1{5})){12}`表示允一个12位数字，但其中不能出现6位连续相同数字。

- 请注意，在有的正则表达式引擎中，使用的八进制转义代码（如 `\16` ）和使用相同表示法的 `\number` 后向引用之间可能会产生多义性。比如，表达式 `([ab])\10`，这里的 `\10` 会被解析成第10个捕获组的反向引用，还是第1个捕获组的反向引用加一个普通字符0呢？不同正则表达式引擎是不一样的。此时，应参看具体的说明文档。如果有多义性问题，可以使用命名捕获组反向引用，该表示法是明确的，并且不会与八进制符号代码混淆。

## 2.11. 注释 {-}

格式 `(?# xxx )` 可用来表示一段注释。

## 2.12. 预搜索 {-}

判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符。

预搜索有向前和向后两种：

|-----------------|------------------|--------------------------------------------------------|
|表达式           |方向              |说明                                                    |
|---{width:15%}---|---{width:20%}----|---{width:20cm}-----------------------------------------|
|`(?=xxx)`        |正向预搜索（向右）|正向预搜索，判断当前位置右侧是否能匹配指定表达式        |
|`(?!xxx)`        |正向预搜索（向右）|正向预搜索否定，判断当前位置右侧是否不能够匹配指定表达式|
|`(?<=xxx)`       |反向预搜索（向左）|反向预搜索，判断当前位置左侧是否能够匹配指定表达式      |
|`(?<!xxx)`       |反向预搜索（向左）|反向预搜索否定，判断当前位置左侧是否不能够匹配指定表达式|
|-----------------|------------------|--------------------------------------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

## 2.13. 条件表达式 {-}
根据某个条件是否成立，来选择匹配 两个可选表达式中的其中一个。

可以用于条件表达式的条件有两种类型：

1. 指定捕获组是否进行了捕获。 
2. 文本中当前位置是否可以与指定表达式匹配。 

条件表达式的格式及说明：

|-----------------------------|-----------------|-------------------------------------------------------|
|表达式                       |条件特点         |条件说明                                               |
|---{width:22%}---------------|---{width:22%}---|---{width:20cm}----------------------------------------|
|[(?(1)yes\|no)]{color:red}   |条件为数字       |分组1如果有捕获，则进行 `yes` 部分匹配，否则 `no` 部分 |
|[(?(?=a)aa\|bbb)]{color:red} |条件为预搜索     |如果当前位置右侧是 `a`，则进行匹配 `aa`，否则匹配 `bbb`|
|[(?(xxx)aa\|bbb)]{color:red} |不与分组命名吻合 |如果不与任何分组命名吻合，则视为 `(?=xxx)` 相同        |
|[(?(name)yes\|no)]{color:red}|与分组命名吻合   |如果与某分组命名吻合，则视为判断该分组是否进行捕获     |
|-----------------------------|-----------------|-------------------------------------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

另外：

- 如果表达式为 RIGHTTOLEFT 模式，那么 `(?(xxx)aa|bbb)` 与 `(?(?<=xxx)aa|bbb)` 相同。 
- 如果条件表达式只有一个选择项，那么这个选项是在条件成立时进行匹配。 
- 如果条件表达式中，使用 `|` 进行分隔的选项多于2个，则只有第一个 `|` 被视为条件表达式选项分隔符。比如：` (?(?=xxx)yes|no1|no2)`，条件成立时，匹配 `yes` 部分，否则匹配 `no1|no2`。 

## 2.14. 递归表达式 {-}

对另一部分子表达式的引用，而不是对其匹配结果的引用。当被引用的表达式包含自身，则形成递归引用。

相对于 "反向引用" 来说，反向引用是在匹配过程中，对匹配到的字符串内容进行引用，而 "递归匹配" 是对表达式进行引用。举例说明：

|------------------|------------------|----------------------|------------------|
|表达式            |等效的表达式1     |等效的表达式2         |可以匹配          |
|---{width:25%}----|---{width:25%}----|---{width:25%}--------|---{width:10cm}---|
|`(\w)(?1)`        |`(\w)(\w)`        |-                     |`ab`              |
|`(?1)(\w(?2))(\d)`|`(?1)(\w(\d))(\d)`|`(\w(\d))(\w(\d))(\d)`|`a1b23`           |
|------------------|------------------|----------------------|------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

如果被引用的表达式又包含自身，则形成了递归引用。举例说明：

|---------------------------------|------------------------------------------------------------|-----------------|------------------|
|表达式                           |等效的表达式1                                               |等效的表达式2    |可以匹配          |
|---{width:25%}-------------------|---{width:30%}----------------------------------------------|---{width:25%}---|---{width:10cm}---|
|`(\w(?1)?)`                      |[(\w(\w(?1)?)?)]{color:red}                                 |`(\w+)`          |`ghjk5……`         |
|`(([^()]`[\|]{color:red}`(?R))*)`|`(([^()]`[\|]{color:red}`(([^()]`[\|]{color:red}`(?R))*))*)`|-                |`(a * (c + 2))`   |
|---------------------------------|------------------------------------------------------------|-----------------|------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

递归表达式格式有：

|--------------------------------|--------------------------|
|格式                            |说明                      |
|---{width:40%}------------------|---{width:20cm}-----------|
|`(?R)`                          |对整个表达式的递归引用。  |
|`(?1)`，`(?2)`，`(?R1)`，`(?R2)`|对指定分组的递归引用。    |
|`(?R<named>)`，`(?R'named')`    |对指定命名分组的递归引用。|
|--------------------------------|--------------------------|
{ tbody-tr-odd-background-color:Gainsboro; tr-even-background-color:White; line-height=2em }

# 3. 正则表达式的建议 {-}

- 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么匹配过程中可能死循环。虽然现在有些正则表达式引擎已经通过办法避免了这种情况出现死循环了，但我们仍然应该尽量避免出现这种情况。
- 表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。
-  合理选择贪婪模式与非贪婪模式。
-  或 `|` 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 `|` 两边的表达式因为交换位置而有所不同。

~ End MainPanel
